var ocKey = process.env.OCKEY;

if (ocKey === undefined) {
    throw new Error('OCKEY envrioment variable is not definned. It must be a valid API key provided by OC\nExample: Set OCKEY=abcd1234');
}

const common = require('./common');
const protobuf = require("protobufjs");
const http = require('http');
const gtfs = require('./runRealtime/gtfs-realtime.proto.js'); //generated by gbf --no-write --legacy
const duckdb = require('duckdb');
const { version } = require('os');

function getDistance(lat1,lat2,lon1,lon2){ //https://stackoverflow.com/a/8299508
    var R = 6371; // km
    var c = Math.PI / 180;
    var dLat = (lat2-lat1) * c;
    var dLon = (lon2-lon1) * c;
    var lat1 = lat1 * c;
    var lat2 = lat2 * c;

    var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); 
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
    var d = R * c;
    return d;
}

async function createTables(db) {
    /*            CREATE TABLE IF NOT EXISTS FeedMessage(
                run_timestamp TIMESTAMP,
                run_id INT,
                id STRING,
                current_stop_sequence INT,
                stop_id STRING,
                currentStatus INT,
                position_bearing FLOAT,
                position_lon FLOAT,
                position_lat FLOAT,
                position_speed FLOAT,
                timestamp UINTEGER,
                trip_direction UINTEGER,
                trip_route varchar(25),
                trip_id varchar(25),
                vehicle_id varchar(25),
                nearest_stop STRING,
                RAW_DATA blob*/

    /*not some columns are not yet implemented by OC, removed for simplicity*/
    return new Promise(resolve => {
        db.all (`            
            CREATE TABLE IF NOT EXISTS FeedMessage(
                run_timestamp STRING,
                run_id INT,
                id STRING,
                position_bearing FLOAT,
                position_lon FLOAT,
                position_lat FLOAT,
                position_speed FLOAT,
                trip_route varchar(25),
                trip_id varchar(25),
                vehicle_id varchar(25),
                nearest_stop STRING
            );`,
            (err, res) => {
                if (err) {
                    console.warn(err);
                }
                //console.log(`   -> Created FeedMessage table `);   
                resolve();             
            }
        );
    });
}

async function getClosest(entity) {  
    return new Promise(resolve => {  
        var closest = null;    
        staticDb.all('select * from stop_times inner join stops on stops.stop_id = stop_times.stop_id where trip_id = ? order by stop_sequence', entity.vehicle.trip.tripId , function(err, res) {
            if (err) {
                console.err(err);
            }                 
            
            var closest, max = Number.MAX_VALUE;
            for (var row of res) {
                //console.log(row)  
                var dist= getDistance(row.stop_lat, entity.vehicle.position.latitude, row.stop_lon, entity.vehicle.position.longitude);
                if (dist < max) {
                    //new closest
                    closest = row.stop_id;
                    max = dist;
                }                    
            }   
            
            resolve(closest);
        });
    });
};

async function getMaxID(realtimeDb) {   
    let a =  new Promise(resolve => {  
        realtimeDb.all("SELECT MAX(run_id) as max_run_id from FeedMessage;" , function(err,res) {
            var runId = 0;
            if (err) {
                console.err(err);
            }
        
            if (res[0].max_run_id != null){            
                runId = res[0].max_run_id + 1;       
            }

            resolve(runId);
        }); 
    }); 

    let b = await a;
    console.log(b)

    return b;
}


/*const options = {
    hostname: common.realtime.ocTranspoHost,
    path: common.realtime.ocTranspoPath,
    method: 'GET',
    headers: {
      'Ocp-Apim-Subscription-Key': ocKey,
    },
};*/

console.log ('OCTranspo Realtime Data Converter');
const options = {    
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: 'numeric', hour12: false,
    minute: "numeric",
    second: "numeric"
  };
const runStart = new Date().toLocaleDateString('en-ca', options);
console.log(runStart);
console.log(common.realtime.getRunname());

//connect to today's static DB
var staticDb = new duckdb.Database('data\\' + common.static.getDBName());

//create / connect to live data table
var realtimeDb = new duckdb.Database('data\\' + common.realtime.getDBName()).connect();
createTables(realtimeDb); //create table if it does not exists

// get next run ID
var runId=-1;

(async() => {   

runId = await getMaxID(realtimeDb);

console.log(`Run ID: ${runId} at ${runStart}`);

let response = await fetch(common.realtime.ocTranspoPath, {
        headers: {'Ocp-Apim-Subscription-Key': ocKey}
});

if (response.ok) {            
    //convert from the proto file
    const arrayBuffer = await response.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    const feedMessage = gtfs.transit_realtime.FeedMessage.decode(buffer);

    //for now save this data and see what it gives
    var insertStatement = realtimeDb.prepare('INSERT INTO FeedMessage VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)');

    feedMessage.entity.forEach(entity => {
        var closestStop = null;
        /*console.log('********************');    
        console.log(entity);    
        console.log('********************');*/
        
        //some trip id may be negative and have scheduleRelationship set to 1 (skipped). not sure how to handle, for now, don't store trip info
        if (entity.vehicle.trip != undefined && entity.vehicle.trip.tripId[0] != '-') {
            /* OC does not provide next stop, so we have to give a go
            * Known limitations of current implementation: cannot handle loops / 2 way traffic. Bearing may help here. Example Walkley station
            * Big gaps will have the wrong stop. ZigZag patterns could have the wrong stop
            * possible fix: use the shapes table instead and look for the closest shape, then next stop by steppping throught shapes. more CPU
            */

            //load up the trip data for this trip - from static data              
            getClosest(entity).then((closestStop) => {
                //add to the db
                insertStatement.run(
                    runStart, runId, entity.id, 
                    entity.vehicle.position.bearing, entity.vehicle.position.longitude, entity.vehicle.position.latitude, entity.vehicle.position.speed,
                    entity.vehicle.trip.routeId, entity.vehicle.trip.tripId,
                    entity.vehicle.vehicle.id,
                    closestStop,  
                    (err, res) => {
                        if (err) {
                            console.warn(`${entity.id}; ${closestStop}`)
                            console.warn(err);
                        }             
                    }
                );  
            });

        } else {
            //add to the db            
            insertStatement.run(
                runStart, runId, entity.id, 
                entity.vehicle.position.bearing, entity.vehicle.position.longitude, entity.vehicle.position.latitude, entity.vehicle.position.speed,
                null, null,  entity.vehicle.vehicle.id, null,
                (err, res) => {
                    if (err) {
                        console.warn(entity.id)
                        console.warn(err);
                    }             
                }
            );
        }
    });  

    insertStatement.finalize();
    realtimeDb.close();    
} else {
    console.error("error:", response.status);
}
})();
