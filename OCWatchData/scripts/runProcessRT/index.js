//load the rt files, match up data
/*const common = require('./common');
const fs = require('fs');
const rtConfig = require('./runRealtime/config.mjs')
const runStatic = require('./runStatic');
const gtfs = require('./runRealtime/gtfs-realtime.proto.js'); //generated by gbf --no-write --legacy
const staticConfig = require('./runStatic/config.mjs')
const duckdb = require('@duckdb/node-api');*/

//import common from '../common/index.js';
import { DuckDBInstance } from '@duckdb/node-api';
import { readFile, access, constants } from 'node:fs/promises';
import { extract, setupDB, createDB} from '../runStatic/index.js';
import { tempPath, realtimePath } from '../runRealtime/config.mjs';
import gtfs from '../gtfs/gtfs-realtime.proto.js'; //generated by gbf --no-write --legacy
import { getClosestStop, convertStopsToArray, convertShapeToArray, getNextStop, convertLocationToPoint } from './gpsFuncs.mjs'

//start processing all the Rt data we have
//later to add command line args to limit to a single day or month

function getMonthName (month) { //helped by AI, but not written
    const date = new Date();
    date.setMonth(month); 
    return date.toLocaleString('default', { month:'short' })
}

//todo, explode messag
        /*for (const key in entity.vehicle) {
            if (Object.hasOwnProperty.call(entity.vehicle, key)) {            
                console.log(`${key}: ${entity.vehicle[key]}`);            
            }
        } */

function createMissingDaily (internalDate) {
    (async() => {
        console.log(`Extracting Daily data for ${internalDate}`)
        await extract(internalDate);
        
        //build the tables into a DuckDB DB, allows to run quick queries        
        console.log(`Generating tables for ${internalDate}`)
        await setupDB(internalDate);
        await createDB(internalDate);
    })();
}



export async function processData() {
    const buffer = await readFile(`${realtimePath}/2025-Dec-30-10-10-30.pb`); //temp for dev purposes
    const feedMessage = gtfs.transit_realtime.FeedMessage.decode(buffer);

    console.log (`Realtime Report was generated by OC on ${feedMessage.header.timestamp}`)

    //feedMessage.entity.forEach(entity => {
    const entity =feedMessage.entity[1]
        if (entity.vehicle.trip !== null) {    
            const reportedTime = new Date(entity.vehicle.timestamp * 1000)
            console.log(`Vehicle ${entity.vehicle.vehicle.id} reported at ${reportedTime} from position ${entity.vehicle.position.latitude},${entity.vehicle.position.longitude} is on trip ${entity.vehicle.trip.tripId} of route ${entity.vehicle.trip.routeId}`)      

            const internalDate = `${entity.vehicle.trip.startDate.slice(0,4)}-${ getMonthName(entity.vehicle.trip.startDate.slice(4,6) - 1) }-${entity.vehicle.trip.startDate.slice(6,8)}`
            console.log(`GTFSExport_${internalDate}`)
            
            //see if DuckDB DB for this report is in cache
            const fileName = `${tempPath}/${internalDate}.db`
            try {
                await access(fileName, constants.F_OK);
            } catch {
                createMissingDaily(internalDate);
            }               
            
            //connect to DB get get route info        
            const duckDBInstance  = await DuckDBInstance.create(fileName);   
            const connection = await duckDBInstance.connect();         

            //get stops for this trip, in order
            const stopsPrepared = await connection.prepare(`
                SELECT arrival_time,stops.stop_id,stop_sequence,timepoint,stop_lat,stop_lon
                FROM stop_times JOIN stops ON stops.stop_id = stop_times.stop_id
                WHERE stop_times.trip_id = $1
                ORDER BY stop_sequence`);
            stopsPrepared.bindVarchar(1, entity.vehicle.trip.tripId);
            const stopsResult = await stopsPrepared.run();
            const tripStops = await stopsResult.getRowObjects();
            const stopsArray = convertStopsToArray(tripStops);

            /*tripStops.forEach(a => {
                console.log(a)
            })*/

            //get the shape of the trip, this will help place the bus near a stop, most of the time
            const shapesPrepared = await connection.prepare(`
                SELECT shapes.shape_id,shape_pt_lat,shape_pt_lon,shape_pt_sequence
                FROM shapes JOIN trips ON trips.shape_id = shapes.shape_id
                WHERE trips.trip_id = $1
                ORDER BY shape_pt_sequence
                `);
            shapesPrepared.bindVarchar(1, entity.vehicle.trip.tripId);
            const shapesResult = await shapesPrepared.run();
            const tripShape = await shapesResult.getRowObjects();
            const shapeArray = convertShapeToArray(tripShape);

            //get a point of our current GPS location
            const curPoint = convertLocationToPoint(entity.vehicle.position.longitude, entity.vehicle.position.latitude)

            //get closet stop, note limitations and implementation in realtimeNotes.md
            //console.log(shapeArray)
            const nearGPS = getNextStop(shapeArray, curPoint, stopsArray, entity.vehicle.position.bearing)
            console.log(`Nearset stop GPS is ${nearGPS.feature.properties.stopId}`) //.properties.stopId

            const closestID = getClosestStop(tripStops, entity.vehicle.position.latitude, entity.vehicle.position.longitude)
            console.log(`Closest stop using naive method is ${closestID}`)
        }   
}