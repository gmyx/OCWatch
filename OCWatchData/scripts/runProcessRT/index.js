import { DuckDBInstance } from '@duckdb/node-api';
import { readFile, access, constants, open } from 'node:fs/promises';
import { extract, setupDB, createDB} from '../runStatic/index.js';
import { tempPath, realtimePath } from '../runRealtime/config.mjs';
import gtfs from '../gtfs/gtfs-realtime.proto.js'; //generated by gbf --no-write --legacy
import { getClosestStop, convertStopsToArray, convertShapeToArray, getNextStop, convertLocationToPoint } from './gpsFuncs.mjs'
import pMap from 'p-map';

//start processing all the Rt data we have
//later to add command line args to limit to a single day or month

function getMonthName (month) { //helped by AI, but not written
    const date = new Date();
    date.setMonth(month); 
    return date.toLocaleString('default', { month:'short' })
}

//todo, explode messag
        /*for (const key in entity.vehicle) {
            if (Object.hasOwnProperty.call(entity.vehicle, key)) {            
                console.log(`${key}: ${entity.vehicle[key]}`);            
            }
        } */

async function createMissingDaily (internalDate) {    
    console.log(`Extracting Daily data for ${internalDate}`)
    await extract(internalDate);
    
    //build the tables into a DuckDB DB, allows to run quick queries        
    console.log(`Generating tables for ${internalDate}`)
    await setupDB(internalDate);
    await createDB(internalDate);    
}

async function getStopsForTrip(tripId, stopsPrepared) {    
    stopsPrepared.bindVarchar(1, tripId);
    const stopsResult = await stopsPrepared.run();
    const tripStops = await stopsResult.getRowObjects();
    return convertStopsToArray(tripStops);   
}

async function getLineStringForTrip(tripId, shapesPrepared) {
    shapesPrepared.bindVarchar(1, tripId);
    const shapesResult = await shapesPrepared.run();
    const tripShape = await shapesResult.getRowObjects();
    return convertShapeToArray(tripShape);
}

export async function processData() {
    const dateString = "2025-Dec-30"
    const inputFileName = `${dateString}-10-10-30`; //temp for dev purposes
    const buffer = await readFile(`${realtimePath}/${inputFileName}.pb`); 
    const feedMessage = gtfs.transit_realtime.FeedMessage.decode(buffer);

    console.log (`Realtime Report was generated by OC on ${feedMessage.header.timestamp}`)

    //see if DuckDB DB for this report is in cache
    const dbFileName = `${tempPath}/${dateString}.db`
    try {
        await access(dbFileName, constants.F_OK);
    } catch {
        createMissingDaily(date);
    }  

    //connect to DB get get route info        
    const duckDBInstance  = await DuckDBInstance.create(dbFileName);         

    //set up output
    const outFile = await open(`${tempPath}/data.csv`, 'w');
    const ws = outFile.createWriteStream();

    //write headers
    ws.write('vehicle_lat,vehicle_lon,vehicle_id,trip_id,reported_time,nearest_stop\n');

    //use array map to execute in parralel
    //const allPromises = feedMessage.entity.map(async entity => {
    
    //for (const entity of feedMessage.entity) {
    const result = await pMap(feedMessage.entity, async entity  => {
        //const entity =feedMessage.entity.at(2);
        if (entity.vehicle.trip !== null) {    
            const reportedTime = new Date(entity.vehicle.timestamp * 1000)
            console.log(`Vehicle ${entity.vehicle.vehicle.id} reported at ${reportedTime} from position ${entity.vehicle.position.latitude},${entity.vehicle.position.longitude} is on trip ${entity.vehicle.trip.tripId} of route ${entity.vehicle.trip.routeId}`)      

            //const internalDate = `${entity.vehicle.trip.startDate.slice(0,4)}-${ getMonthName(entity.vehicle.trip.startDate.slice(4,6) - 1) }-${entity.vehicle.trip.startDate.slice(6,8)}`
            //console.log(`GTFSExport_${dateString}`)          
          
            //connect to DB - each 'thread' needs its own connection
            const connection = await duckDBInstance.connect(); 

            //create prepared statement for stops
            const stopsPrepared = await connection.prepare(`
                SELECT arrival_time,stops.stop_id,stop_sequence,timepoint,stop_lat,stop_lon
                FROM stop_times JOIN stops ON stops.stop_id = stop_times.stop_id
                WHERE stop_times.trip_id = $1
                ORDER BY stop_sequence`);

            //create prepared statement for shape (lineString)
            const shapesPrepared = await connection.prepare(`
                SELECT shapes.shape_id,shape_pt_lat,shape_pt_lon,shape_pt_sequence
                FROM shapes JOIN trips ON trips.shape_id = shapes.shape_id
                WHERE trips.trip_id = $1
                ORDER BY shape_pt_sequence`);

            //create prepared statement to find a route
            const routesPrepared = await connection.prepare(`
                SELECT route_id 
                FROM routes
                WHERE route_id = $1`);

            //see if this route is in the catelog, not all routes are (probably chartered or something)
            routesPrepared.bindVarchar(1, entity.vehicle.trip.routeId);
            const routesResult = await routesPrepared.run();
            const routes = await routesResult.getRowObjects();

            if (routes.length === 0) {
                console.log(`Unkown route ${entity.vehicle.trip.routeId} on trip ${entity.vehicle.trip.tripId}`);
                return null; //do nothing
            }

            //get the stops for this trip
            const stopsArray = await getStopsForTrip(entity.vehicle.trip.tripId, stopsPrepared);            

            //get the shape of the trip, this will help place the bus near a stop, most of the time
            const shapeArray = await getLineStringForTrip(entity.vehicle.trip.tripId, shapesPrepared);

            //get a point of our current GPS location
            const curPoint = convertLocationToPoint(entity.vehicle.position.longitude, entity.vehicle.position.latitude)

            //get closet stop, note limitations and implementation in realtimeNotes.md
            const nearGPS = getNextStop(shapeArray, curPoint, stopsArray, entity.vehicle.position.bearing)
            if (nearGPS === undefined) {
                console.log(`Could not find nearest stop for trip ${entity.vehicle.trip.tripId}. please investigate this trip report.`);
            }
            console.log(`Nearset stop for trip ${entity.vehicle.trip.tripId} is ${nearGPS.feature.properties.stopId}`) //.properties.stopId

            //save what we found to a file (db later?)
            //'vehicle_lat,vehicle_lon,vehicle_id,trip_id,reported_time,nearest_stop'
            ws.write(`${entity.vehicle.position.latitude},${entity.vehicle.position.longitude},${entity.vehicle.vehicle.id},${entity.vehicle.trip.tripId},${reportedTime}, ${nearGPS.feature.properties.stopId}\n`)            
        }   
    }, {concurrency: 50});

    //await Promise.all(allPromises);
    //await (allPromises);

    //close out
    ws.close()
}